---
title: "Task 5"
output: 
  pdf_document: 
    latex_engine: xelatex
editor_options: 
  chunk_output_type: console
---

```{r setup5, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

# Task 5
```{r Task_5_setup, include=FALSE}
base_url <- '~/GitHub/kul-multivariate-a2/src/'
load(paste0(base_url,"confusion.Rdata"))
library(smacof)
library(dplyr)
library(qdapRegex)
library(stringr)
library(kableExtra)
```

## Introduction
  In this part of the assignment, we are going to work with a morse code signal perception dataset.
  
  The dataset which contains a 36 x 36 matrix of confusion rates for all pairs of signals included in the study. The signals in the subsequent rows of the confusing matrix are the letters of the alphabet A, B, C… in alphabetical order and the numbers 1,2,3,4,5,6,7,8,9,0.
  
  The value in cell (i,j) of the matrix represents the percentage of subjects who indicated that signal i was equal to signal j, when signal j was presented after signal i.
 
  Here, we will search similarities and dissimilarities about the perception of the people which participated in this study.
  
  Multidimensional Scaling will be use.  
  
  Data, looks like this 
  
```{r Task_5_00, eval=TRUE, include=TRUE, echo=FALSE}
looklike <- confusion
colnames(looklike) <- str_replace_all(colnames(looklike), " ", "")
rownames(looklike) <- str_replace_all(colnames(looklike), " ", "")

looklike[c(1:8), c(1:8)] %>%
kbl(caption = "extract of confussion matrix") %>%
kable_minimal(full_width = T, html_font = "Cambria") %>% 
kable_styling(latex_options = c("hold_position"))
```

## Methodology
   In order to observe dissimilarities and understand them, we are going to work with  in this matrix and find a solution, some methods as _randomstress()_ and permutation() will be used. 
   
   This data is "Tree-way two-mode", that means a that multiple persons rate the similarity between all pairs of objects, in this case, that people rate if two signal are similar or not.
   
  Firstly, and this one is to simplify the analysis, is transform signals into alphabet and numbers. After that  is transform data to create a new symmetric dissimilarity matrix.
  
  Secondly, we will Use MDS to get the optimal staled dissimilarities in order to select the better model to use in the analysis based in the goodness of fit and investigate the stability of the selected solution.
  
  And Finally,   Interpret the results  
   
   
\newpage

## Results

### Step 1

  Here, we use couple of simple steps to help the interpretation of our analysis.

```{r Task_5_0 , include=TRUE , eval=TRUE}
#A readable Matrix 
alphabet <- c(letters,1:9,0)
translate <- confusion
colnames(translate) <- alphabet
rownames(translate) <- alphabet
```

### Step 2

  After that, a transformation matrix have to be  applied.

```{r Task_5_1 , include=TRUE , eval=TRUE}
#Looking a dissimilarity Matrix
#1.Similarity
t.sim <- (translate+t(translate))/2 
#2.Dissimilarity
t.dissim <- 100-t.sim 
for (i in 1:36){
#3.Diagonal 
  t.dissim[i,i]<-0   
} 
```

### Step 3
  Using the *smacofSym()* conduct MDS with 2 dimensions in order to "process.." and check different measurement *_levels, ratio, interval, mspline and ordinal_* are going to be use, and avoiding to get stuck about the local minimum, will be use configuration of _torgeson_ as a classical scaling starting solution.
  
```{r Task_5_2 , include=TRUE , eval=TRUE}
#ratio
t.m1 <- smacofSym(delta=t.dissim, ndim=2, type="ratio", init="torgerson")
#intervalas
t.m2 <- smacofSym(delta=t.dissim, ndim=2, type="interval", init="torgerson")
#mspline
t.m3 <- smacofSym(delta=t.dissim, ndim=2, type="mspline", spline.degree =4, 
                spline.intKnots = 4, init="torgerson")
#ordinal
t.m4 <- smacofSym(delta=t.dissim, ndim=2, type="ordinal", init="torgerson")

```
```{r Task_5_3 , include=FALSE, eval=TRUE}
## jUST df creation to be used in kable
t.dt <- data.frame(
  "ratio" = round(c(t.m1$stress),3),
  "interval" = round(c(t.m2$stress),3),
  "mspline" = round(c(t.m3$stress),3),
  "ordinal" = round(c(t.m4$stress),3)
)
```

  Once obtain the evaluation of *************** we proceed to apply our first judgment.

```{r Task_5_4, include=TRUE , eval=TRUE, echo=FALSE}
t.dt %>%
  kbl(caption = "Stress-1  table values") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>% 
  kable_styling(latex_options = c("hold_position"))
```

  Following this rule 
  
  \begin{table}[h!]
  \begin{center}
    \caption{Rule Of thumb}
      \begin{tabular}{c|c|c|c|c} 
      \textbf{ Perfect } & \textbf{Perfect} & \textbf{Good} & \textbf{Fair} & \textbf{Poor}\\
      \hline
        0 & 0.025 & 0.05 & 0.10 & 0.20 \\ 
      \end{tabular}
  \end{center}
\end{table}

  Our first decision is "ordinal" has to be used, because is a better value among those. 
  
\newpage
```{r Task_5_5 , include=TRUE , echo=FALSE}
par(mfrow=c(3,1))
plot(t.m3,plot.type="resplot",main="residual plot ordinal MDS")
plot(t.m3,plot.type="Shepard",main="Shepard diagram ordinal MDS")

```

```{r Task_5_6 , include=TRUE , echo=FALSE}
plot(t.m3,plot.type="conf")
```

### Step 4

  Here, we are going to evaluate the goodness of fit of solutions for those  measurement levels using _stress-1_
      In the previous step, the minor value was the "ordinal", for that reason will be use to evaluate the goodness of fit. 

  In the process evaluate the goodness of fit of solution, we will observe _stress-1_. 

  Randomstress function help to understand our parameter which has to be compared with............********.
  
  Seed is setted in $290685$

```{r Task_5_7 , include=TRUE, eval=TRUE, echo=FALSE}
set.seed(290685)
rstress<-randomstress(n=36,ndim=2,nrep=500,type="ordinal")

#distribution of stress for random data
dsrd <- mean(rstress)-2*sd(rstress)
data.frame(dsrd) %>%
  kbl(caption = "Stress for random data") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>% 
  kable_styling(latex_options = c("hold_position"))

```
  
  Our first step is use permute test to put our data inside ... 

```{r Task_5_8 , include=TRUE, eval=FALSE}
#permutation test
set.seed(290685)
t.perm.morse<-permtest(t.m4,nrep=500,verbose = FALSE)
```

  Graphic information related previous two steps.

```{r Task_5_9 , include=TRUE, eval=FALSE}
#plot distribution stress
par(mfrow=c(2,1),pty="s")
hist(rstress,main="stress random data")
hist(t.perm.morse$stressvec, main="stress permuted data")
```
  
  Considering that our number... was... this fit as a good model.
  
```{r Task_5_10, include=TRUE, eval=FALSE}
#stability of solution using jackknife
jack.morse<-jackmds(t.m3)
plot(jack.morse,xlim=c(-1.2,1.2),ylim=c(-1,1))

boot.morse.p <- bootmds(t.m3, data = dissim, nrep = 500, method.dat = "pearson")
plot(boot.morse.p)
```

### Step 5
  
  A external matrix which will help to understand some similarities and dissimilarities is created for this step
  
```{r Task_5_11, include=TRUE, eval=TRUE}
v_signal <- colnames(confusion)
v_signal <- str_replace_all(v_signal, " ", "")
v_signal <- str_replace_all(v_signal, "·", ".")
alphabet <- c(letters,1:9,0)
another_matrix <- data.frame(v_signal) %>% mutate(alph = alphabet, 
         size = nchar(v_signal), 
         ndots =  str_count(v_signal, "\\."),
         nlines = str_count(v_signal, "-"),
         time = (str_count(v_signal, "\\.")*0.05)+(str_count(v_signal,"-")*0.15),
         t_s_length = (nchar(v_signal) -1 )*0.05, 
         dots_s_length = (str_count(v_signal,"\\.")*0.05),
         lines_s_length = (str_count(v_signal,"-")*0.15)) 
```

```{r Task_5_12, include=FALSE, eval=TRUE, echo=TRUE}
another_matrix %>%
  kbl(caption = "New Matrix") %>%
  kable_classic(full_width = F, html_font = "Cambria") %>% 
  kable_styling(latex_options = c("hold_position"))
```



```{r Task_5_13, include=TRUE}
#conduct ordinal MDS analysis
t.fit <- mds(t.dissim, type = "ordinal")
#compute MDS biplot: run multivariate linear regression of
#external variables on configuration
biFace <- biplotmds(t.fit, another_matrix[,-c(1,2,7,8,9)])
# project external variables in the MDS solution
plot(biFace, main = "Biplot Representation", vecscale = 0.8,
xlim = c(-1.5, 1.5), vec.conf = list(col = "brown"), pch = 20, cex = 0.7)

```



3. Construct a data set of external variables that describe the signals (e.g. length of the signal, proportion of short beeps in the signal, etc.). Use an _MDS biplot_ to project the external variables in the configuration plot of the selected solution, and interpret the results of the analysis. 